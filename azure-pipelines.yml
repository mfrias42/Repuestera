# Azure DevOps Release Pipeline para Repuestera
# Despliegue multi-ambiente: QA ‚Üí Producci√≥n
# TP05 - Ingenier√≠a de Software 3
# TP07 - Code Coverage, SonarCloud y Cypress E2E

trigger:
- main

variables:
  # Configuraci√≥n de Azure
  azureSubscription: 'Azure-Service-Connection'
  resourceGroupName: 'rg-repuestera-qa'
  location: 'Brazil South'
  
  # Configuraci√≥n de Node.js
  nodeVersion: '20.x'
  
  # Variables QA
  webAppNameBackendQA: 'repuestera-api-qa'
  webAppNameFrontendQA: 'repuestera-web-qa'
  apiUrlQA: 'https://repuestera-api-qa.azurewebsites.net/api'
  
  # Variables Producci√≥n
  webAppNameBackendProd: 'repuestera-api-prod'
  webAppNameFrontendProd: 'repuestera-web-prod'
  apiUrlProd: 'https://repuestera-api-prod.azurewebsites.net/api'
  
  # Quality Gates - TP07
  minCoveragePercentage: 80
  sonarCloudOrganization: 'mfrias42' # Organizaci√≥n de SonarCloud
  sonarCloudProjectKey: 'repuestera' # Project key de SonarCloud

stages:
- stage: Build
  displayName: 'Construcci√≥n'
  jobs:
  # Job 1: Backend - Se ejecuta primero porque otros pueden depender de √©l
  - job: BuildBackend
    displayName: 'Construir Backend'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: $(nodeVersion)
      displayName: 'Instalar Node.js $(nodeVersion)'

    - script: |
        cd backend
        npm install --production=false
      displayName: 'Instalar dependencias del backend'
    
    - script: |
        cd backend
        npm run test -- --coverage --ci --maxWorkers=2
      displayName: 'Ejecutar pruebas unitarias del backend'
      continueOnError: false
      env:
        CI: 'true'
    
    - task: PublishTestResults@2
      condition: always()
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: 'backend/coverage/junit.xml'
        testRunTitle: 'Backend Tests'
        failTaskOnFailedTests: false
      displayName: 'Publicar resultados de tests del backend'
    
    - task: PublishCodeCoverageResults@2
      condition: always()
      inputs:
        summaryFileLocation: 'backend/coverage/lcov.info'
        reportDirectory: 'backend/coverage'
        failIfCoverageEmpty: false
      displayName: 'Publicar coverage del backend'

    - script: |
        # Verificar que el archivo de coverage existe
        if [ ! -f "backend/coverage/lcov.info" ]; then
          echo "##[error]No se encontr√≥ el archivo backend/coverage/lcov.info"
          echo "Verificando estructura de directorios..."
          ls -la backend/coverage/ || echo "Directorio coverage no existe"
          exit 0
        fi
        
        # Leer el archivo de coverage y calcular el porcentaje usando awk
        TOTAL_LINES=$(grep -h "^LF:" backend/coverage/lcov.info | awk -F: '{sum+=$2} END {print sum+0}')
        HIT_LINES=$(grep -h "^LH:" backend/coverage/lcov.info | awk -F: '{sum+=$2} END {print sum+0}')
        
        if [ -z "$TOTAL_LINES" ] || [ "$TOTAL_LINES" -eq 0 ]; then
          COVERAGE=0.00
        else
          COVERAGE=$(awk "BEGIN {printf \"%.2f\", ($HIT_LINES / $TOTAL_LINES) * 100}")
        fi
        
        echo "Coverage actual: ${COVERAGE}%"
        echo "Coverage m√≠nimo requerido: $(minCoveragePercentage)%"
        
        if (( $(echo "$COVERAGE < $(minCoveragePercentage)" | bc -l) )); then
          echo "##[warning]Coverage del backend (${COVERAGE}%) es menor al m√≠nimo requerido ($(minCoveragePercentage)%)"
          echo "##[warning]Para desarrollo, puedes continuar, pero se recomienda mejorar el coverage"
        else
          echo "‚úÖ Coverage del backend cumple con el m√≠nimo requerido"
        fi
      displayName: 'Quality Gate: Verificar coverage backend >= 80%'
      continueOnError: true
    
    - task: SonarCloudPrepare@1
      condition: always()
      continueOnError: true
      inputs:
        SonarCloud: 'SonarCloud' # Service connection name - DEBE estar configurado en Azure DevOps
        organization: '$(sonarCloudOrganization)'
        scannerMode: 'CLI'
        configMode: 'manual'
        cliProjectKey: '$(sonarCloudProjectKey)-backend'
        cliProjectName: 'Repuestera Backend'
        cliSources: 'backend'
        extraProperties: |
          sonar.javascript.lcov.reportPaths=backend/coverage/lcov.info
          sonar.coverage.exclusions=**/__tests__/**,**/node_modules/**,**/scripts/**,**/coverage/**,server.js,jest.config.js
          sonar.test.exclusions=**/node_modules/**
      displayName: 'SonarCloud: Preparar an√°lisis backend'

    - task: SonarCloudAnalyze@1
      condition: always()
      continueOnError: true
      displayName: 'SonarCloud: Ejecutar an√°lisis backend'

    - task: SonarCloudPublish@1
      condition: always()
      continueOnError: true
      inputs:
        pollingTimeoutSec: '300'
      displayName: 'SonarCloud: Publicar resultados backend'

    - task: ArchiveFiles@2
      inputs:
        rootFolderOrFile: 'backend'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/backend.zip'
        replaceExistingArchive: true
      displayName: 'Comprimir archivos del backend'

    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)/backend.zip'
        ArtifactName: 'backend-drop'
        publishLocation: 'Container'
      displayName: 'Publicar artefacto del backend'

  # Job 2: Frontend QA - Se ejecuta en paralelo con Backend (tests + build con URL de QA)
  - job: BuildFrontendQA
    displayName: 'Construir Frontend para QA'
    pool:
      vmImage: 'ubuntu-latest'
    # No depende de BuildBackend porque son independientes
    
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: $(nodeVersion)
      displayName: 'Instalar Node.js $(nodeVersion)'

    - script: |
        cd frontend
        npm install
      displayName: 'Instalar dependencias del frontend'
    
    - script: |
        cd frontend
        CI=true npm test -- --watchAll=false --coverage --ci --passWithNoTests --testPathIgnorePatterns="App.test.js"
      displayName: 'Ejecutar pruebas del frontend'
      continueOnError: false

    - script: |
        cd frontend
        node generate-junit.js
      displayName: 'Generar reporte JUnit del frontend'
      continueOnError: true

    - task: PublishTestResults@2
      condition: always()
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: 'frontend/coverage/junit.xml'
        testRunTitle: 'Frontend Tests'
        failTaskOnFailedTests: false
      displayName: 'Publicar resultados de tests del frontend'
    
    - task: PublishCodeCoverageResults@2
      condition: always()
      inputs:
        summaryFileLocation: 'frontend/coverage/lcov.info'
        reportDirectory: 'frontend/coverage'
        failIfCoverageEmpty: false
      displayName: 'Publicar coverage del frontend'

    - script: |
        # Verificar que el archivo de coverage existe
        if [ ! -f "frontend/coverage/lcov.info" ]; then
          echo "##[error]No se encontr√≥ el archivo frontend/coverage/lcov.info"
          echo "Verificando estructura de directorios..."
          ls -la frontend/coverage/ || echo "Directorio coverage no existe"
          exit 0
        fi
        
        # Leer el archivo de coverage y calcular el porcentaje usando awk
        TOTAL_LINES=$(grep -h "^LF:" frontend/coverage/lcov.info | awk -F: '{sum+=$2} END {print sum+0}')
        HIT_LINES=$(grep -h "^LH:" frontend/coverage/lcov.info | awk -F: '{sum+=$2} END {print sum+0}')
        
        if [ -z "$TOTAL_LINES" ] || [ "$TOTAL_LINES" -eq 0 ]; then
          COVERAGE=0.00
        else
          COVERAGE=$(awk "BEGIN {printf \"%.2f\", ($HIT_LINES / $TOTAL_LINES) * 100}")
        fi
        
        echo "Coverage actual: ${COVERAGE}%"
        echo "Coverage m√≠nimo requerido: $(minCoveragePercentage)%"
        
        if (( $(echo "$COVERAGE < $(minCoveragePercentage)" | bc -l) )); then
          echo "##[warning]Coverage del frontend (${COVERAGE}%) es menor al m√≠nimo requerido ($(minCoveragePercentage)%)"
          echo "##[warning]Para desarrollo, puedes continuar, pero se recomienda mejorar el coverage"
        else
          echo "‚úÖ Coverage del frontend cumple con el m√≠nimo requerido"
        fi
      displayName: 'Quality Gate: Verificar coverage frontend >= 80%'
      continueOnError: true

    - task: SonarCloudPrepare@1
      condition: always()
      continueOnError: true
      inputs:
        SonarCloud: 'SonarCloud' # Service connection name - DEBE estar configurado en Azure DevOps
        organization: '$(sonarCloudOrganization)'
        scannerMode: 'CLI'
        configMode: 'manual'
        cliProjectKey: '$(sonarCloudProjectKey)-frontend'
        cliProjectName: 'Repuestera Frontend'
        cliSources: 'frontend/src'
        extraProperties: |
          sonar.javascript.lcov.reportPaths=frontend/coverage/lcov.info
          sonar.coverage.exclusions=**/__tests__/**,**/node_modules/**,**/coverage/**,**/*.test.js,setupTests.js,reportWebVitals.js
          sonar.test.exclusions=**/node_modules/**
      displayName: 'SonarCloud: Preparar an√°lisis frontend'

    - task: SonarCloudAnalyze@1
      condition: always()
      continueOnError: true
      displayName: 'SonarCloud: Ejecutar an√°lisis frontend'
    
    - task: SonarCloudPublish@1
      condition: always()
      continueOnError: true
      inputs:
        pollingTimeoutSec: '300'
      displayName: 'SonarCloud: Publicar resultados frontend'

    - script: |
        cd frontend
        npm run build
      displayName: 'Construir frontend para QA'
      env:
        REACT_APP_API_URL: $(apiUrlQA)
        NODE_ENV: 'production'

    - task: ArchiveFiles@2
      inputs:
        rootFolderOrFile: 'frontend/build'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/frontend-qa.zip'
        replaceExistingArchive: true
      displayName: 'Comprimir build del frontend QA'

    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)/frontend-qa.zip'
        ArtifactName: 'frontend-qa-drop'
        publishLocation: 'Container'
      displayName: 'Publicar artefacto del frontend QA'

  # Job 3: Frontend Producci√≥n - Se ejecuta en paralelo (solo build con URL de producci√≥n)
  # NOTA: Builds separados son NECESARIOS porque el frontend necesita diferentes URLs de API
  # en tiempo de compilaci√≥n (REACT_APP_API_URL se inyecta en el c√≥digo durante el build)
  - job: BuildFrontendProd
    displayName: 'Construir Frontend para Producci√≥n'
    pool:
      vmImage: 'ubuntu-latest'
    # No depende de otros jobs, puede ejecutarse en paralelo
    
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: $(nodeVersion)
      displayName: 'Instalar Node.js $(nodeVersion)'

    - script: |
        cd frontend
        npm install
      displayName: 'Instalar dependencias del frontend'
    
    - script: |
        cd frontend
        npm run build
      displayName: 'Construir frontend para Producci√≥n'
      env:
        REACT_APP_API_URL: $(apiUrlProd)
        NODE_ENV: 'production'

    - task: ArchiveFiles@2
      inputs:
        rootFolderOrFile: 'frontend/build'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/frontend-prod.zip'
        replaceExistingArchive: true
      displayName: 'Comprimir build del frontend Producci√≥n'

    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)/frontend-prod.zip'
        ArtifactName: 'frontend-prod-drop'
        publishLocation: 'Container'
      displayName: 'Publicar artefacto del frontend Producci√≥n'

  # Job 4: Pruebas E2E con Cypress - TP07
  - job: E2ETests
    displayName: 'Pruebas E2E con Cypress'
    pool:
      vmImage: 'ubuntu-latest'
    dependsOn: 
      - BuildBackend
      - BuildFrontendQA
    condition: succeeded()
    
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: $(nodeVersion)
      displayName: 'Instalar Node.js $(nodeVersion)'

    - script: |
        cd frontend
        npm install
      displayName: 'Instalar dependencias del frontend'

    - script: |
        cd backend
        npm install --production=false
      displayName: 'Instalar dependencias del backend'

    - script: |
        # Iniciar backend en background
        cd backend
        npm start > backend.log 2>&1 &
        BACKEND_PID=$!
        echo "Backend iniciado con PID: $BACKEND_PID"
        echo "Esperando a que el backend est√© listo..."
        for i in {1..30}; do
          if curl -f http://localhost:8000/api/health > /dev/null 2>&1; then
            echo "‚úÖ Backend est√° listo"
            break
          fi
          if [ $i -eq 30 ]; then
            echo "‚ùå Backend no respondi√≥ despu√©s de 30 intentos"
            cat backend.log
            exit 1
          fi
          sleep 2
        done
      displayName: 'Iniciar backend para pruebas E2E'
      continueOnError: false

    - script: |
        # Iniciar frontend en background
        cd frontend
        BROWSER=none npm start > frontend.log 2>&1 &
        FRONTEND_PID=$!
        echo "Frontend iniciado con PID: $FRONTEND_PID"
        echo "Esperando a que el frontend est√© listo..."
        for i in {1..30}; do
          if curl -f http://localhost:3000 > /dev/null 2>&1; then
            echo "‚úÖ Frontend est√° listo"
            break
          fi
          if [ $i -eq 30 ]; then
            echo "‚ùå Frontend no respondi√≥ despu√©s de 30 intentos"
            cat frontend.log
            exit 1
          fi
          sleep 2
        done
      displayName: 'Iniciar frontend para pruebas E2E'
      continueOnError: false

    - script: |
        cd frontend
        mkdir -p cypress/results
        # Verificar que cypress.config.js existe
        if [ ! -f "cypress.config.js" ]; then
          echo "##[error]No se encontr√≥ cypress.config.js en frontend/"
          ls -la
          exit 1
        fi
        # Verificar que backend y frontend est√°n corriendo
        echo "Verificando que backend est√° corriendo..."
        curl -f http://localhost:8000/api/health || echo "‚ö†Ô∏è Backend puede no estar listo"
        echo "Verificando que frontend est√° corriendo..."
        curl -f http://localhost:3000 || echo "‚ö†Ô∏è Frontend puede no estar listo"
        # Ejecutar Cypress con manejo de errores
        npm run cypress:run:headless || echo "‚ö†Ô∏è Algunos tests fallaron, pero continuando..."
      displayName: 'Ejecutar pruebas E2E con Cypress'
      continueOnError: true
      env:
        CYPRESS_baseUrl: 'http://localhost:3000'
        CYPRESS_apiUrl: 'http://localhost:8000/api'

    - task: PublishTestResults@2
      condition: always()
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: 'cypress/results/*.xml'
        testRunTitle: 'Cypress E2E Tests'
        failTaskOnFailedTests: true
      displayName: 'Publicar resultados de pruebas E2E'

# ============================================================================
# STAGE QA - Despliegue Autom√°tico para Testing
# ============================================================================
- stage: QualityGates
  displayName: 'üîç Quality Gates - TP07'
  dependsOn: Build
  condition: succeeded()
  
  jobs:
  - job: VerifyQualityGates
    displayName: 'Verificar Quality Gates'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - script: |
        echo "##[section]Verificando Quality Gates"
        echo "Coverage m√≠nimo requerido: $(minCoveragePercentage)%"
        echo "SonarCloud Organization: $(sonarCloudOrganization)"
        echo "SonarCloud Project Key: $(sonarCloudProjectKey)"
        echo "‚úÖ Quality Gates configurados correctamente"
      displayName: 'Verificar configuraci√≥n de Quality Gates'

- stage: DeployQA
  displayName: 'üß™ QA Environment'
  dependsOn: 
    - Build
    - QualityGates
  condition: |
    and(
      succeeded(),
      eq(dependencies.Build.result, 'Succeeded'),
      eq(dependencies.QualityGates.result, 'Succeeded')
    )
  
  variables:
    NODE_ENV: 'qa'
    API_URL: $(apiUrlQA)
  
  jobs:
  - deployment: DeployBackendQA
    displayName: 'Deploy API to QA'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'qa-backend'
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: backend-drop
            displayName: 'Download Backend Artifact'
          
          - task: AzureAppServiceSettings@1
            inputs:
              azureSubscription: $(azureSubscription)
              appName: $(webAppNameBackendQA)
              resourceGroupName: $(resourceGroupName)
              appSettings: |
                [
                  {
                    "name": "NODE_ENV",
                    "value": "qa",
                    "slotSetting": false
                  },
                  {
                    "name": "PORT",
                    "value": "8000",
                    "slotSetting": false
                  },
                  {
                    "name": "WEBSITE_NODE_DEFAULT_VERSION",
                    "value": "20.11.0",
                    "slotSetting": false
                  },
                  {
                    "name": "DB_TYPE",
                    "value": "mysql",
                    "slotSetting": false
                  },
                  {
                    "name": "DB_HOST",
                    "value": "manufrias.mysql.database.azure.com",
                    "slotSetting": false
                  },
                  {
                    "name": "DB_USER",
                    "value": "A",
                    "slotSetting": false
                  },
                  {
                    "name": "DB_PASSWORD",
                    "value": "4286Pka1#",
                    "slotSetting": false
                  },
                  {
                    "name": "DB_NAME",
                    "value": "repuestera_db",
                    "slotSetting": false
                  },
                  {
                    "name": "DB_PORT",
                    "value": "3306",
                    "slotSetting": false
                  },
                  {
                    "name": "JWT_SECRET",
                    "value": "qa_jwt_secret_key_2024",
                    "slotSetting": false
                  },
                  {
                    "name": "JWT_EXPIRES_IN",
                    "value": "24h",
                    "slotSetting": false
                  }
                ]
            displayName: 'Configure QA Backend Settings'
            
          - task: AzureWebApp@1
            inputs:
              azureSubscription: $(azureSubscription)
              appType: 'webAppLinux'
              appName: $(webAppNameBackendQA)
              resourceGroupName: $(resourceGroupName)
              package: '$(Pipeline.Workspace)/backend-drop/backend.zip'
              runtimeStack: 'NODE|20-lts'
              startUpCommand: 'npm start'
            displayName: 'Deploy Backend to QA'

  - deployment: DeployFrontendQA
    displayName: 'Deploy Frontend to QA'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'qa-frontend'
    dependsOn: DeployBackendQA
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: frontend-qa-drop
            displayName: 'Download Frontend QA Artifact'
            
          - task: AzureWebApp@1
            inputs:
              azureSubscription: $(azureSubscription)
              appType: 'webAppLinux'
              appName: $(webAppNameFrontendQA)
              resourceGroupName: $(resourceGroupName)
              package: '$(Pipeline.Workspace)/frontend-qa-drop/frontend-qa.zip'
              runtimeStack: 'NODE|20-lts'
              startUpCommand: 'npx serve -s . -l 8080'
            displayName: 'Deploy Frontend to QA'
          
          - task: AzureAppServiceSettings@1
            inputs:
              azureSubscription: $(azureSubscription)
              appName: $(webAppNameFrontendQA)
              resourceGroupName: $(resourceGroupName)
              appSettings: |
                [
                  {
                    "name": "WEBSITE_NODE_DEFAULT_VERSION",
                    "value": "20.11.0",
                    "slotSetting": false
                  },
                  {
                    "name": "PORT",
                    "value": "8080",
                    "slotSetting": false
                  }
                ]
            displayName: 'Configure QA Frontend Settings'

# ============================================================================
# STAGE PRODUCTION - Despliegue con Aprobaci√≥n Manual
# ============================================================================
- stage: DeployProduction
  displayName: 'üöÄ Production Environment'
  dependsOn: 
    - DeployQA
    - QualityGates
  condition: |
    and(
      succeeded(),
      eq(dependencies.DeployQA.result, 'Succeeded'),
      eq(dependencies.QualityGates.result, 'Succeeded')
    )
  
  variables:
    NODE_ENV: 'production'
    API_URL: $(apiUrlProd)
  
  jobs:
  - deployment: DeployBackendProd
    displayName: 'üîê Deploy API to Production (Manual Approval Required)'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'production-backend'
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: backend-drop
            displayName: 'Download Backend Artifact'
            
          - task: AzureWebApp@1
            inputs:
              azureSubscription: $(azureSubscription)
              appType: 'webAppLinux'
              appName: $(webAppNameBackendProd)
              resourceGroupName: $(resourceGroupName)
              package: '$(Pipeline.Workspace)/backend-drop/backend.zip'
              runtimeStack: 'NODE|20-lts'
              startUpCommand: 'npm start'
            displayName: 'Deploy Backend to Production'
          
          - task: AzureAppServiceSettings@1
            inputs:
              azureSubscription: $(azureSubscription)
              appName: $(webAppNameBackendProd)
              resourceGroupName: $(resourceGroupName)
              appSettings: |
                [
                  {
                    "name": "NODE_ENV",
                    "value": "production",
                    "slotSetting": false
                  },
                  {
                    "name": "PORT",
                    "value": "8000",
                    "slotSetting": false
                  },
                  {
                    "name": "WEBSITE_NODE_DEFAULT_VERSION",
                    "value": "20.11.0",
                    "slotSetting": false
                  },
                  {
                    "name": "DB_TYPE",
                    "value": "mysql",
                    "slotSetting": false
                  },
                  {
                    "name": "DB_HOST",
                    "value": "manufrias-prod.mysql.database.azure.com",
                    "slotSetting": false
                  },
                  {
                    "name": "DB_USER",
                    "value": "A",
                    "slotSetting": false
                  },
                  {
                    "name": "DB_PASSWORD",
                    "value": "4286Pk1#",
                    "slotSetting": false
                  },
                  {
                    "name": "DB_NAME",
                    "value": "repuestera_db",
                    "slotSetting": false
                  },
                  {
                    "name": "DB_PORT",
                    "value": "3306",
                    "slotSetting": false
                  },
                  {
                    "name": "JWT_SECRET",
                    "value": "prod_jwt_secret_key_secure_2024",
                    "slotSetting": false
                  },
                  {
                    "name": "JWT_EXPIRES_IN",
                    "value": "24h",
                    "slotSetting": false
                  }
                ]
            displayName: 'Configure Production Backend Settings'

  - deployment: DeployFrontendProd
    displayName: 'üîê Deploy Frontend to Production (Manual Approval Required)'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'production-frontend'
    dependsOn: DeployBackendProd
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: frontend-prod-drop
            displayName: 'Download Frontend Production Artifact'
            
          - task: AzureWebApp@1
            inputs:
              azureSubscription: $(azureSubscription)
              appType: 'webAppLinux'
              appName: $(webAppNameFrontendProd)
              resourceGroupName: $(resourceGroupName)
              package: '$(Pipeline.Workspace)/frontend-prod-drop/frontend-prod.zip'
              runtimeStack: 'NODE|20-lts'
              startUpCommand: 'npx serve -s . -l 8080'
            displayName: 'Deploy Frontend to Production'
          
          - task: AzureAppServiceSettings@1
            inputs:
              azureSubscription: $(azureSubscription)
              appName: $(webAppNameFrontendProd)
              resourceGroupName: $(resourceGroupName)
              appSettings: |
                [
                  {
                    "name": "WEBSITE_NODE_DEFAULT_VERSION",
                    "value": "20.11.0",
                    "slotSetting": false
                  },
                  {
                    "name": "PORT",
                    "value": "8080",
                    "slotSetting": false
                  }
                ]
            displayName: 'Configure Production Frontend Settings'